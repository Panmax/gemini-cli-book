# 第四章：玩转文件与上下文

在第一部分中，我们学习了 Gemini CLI 的基础知识。从本章开始，我们将深入探讨其核心功能，而其中最关键、最能体现 Gemini CLI 威力的，莫过于其强大的上下文管理能力。理解并善用上下文，是您从入门到精通的必经之路。

上下文（Context）是指您在与 Gemini 模型对话时提供给它的相关信息。上下文越准确、越充分，模型给出的回答就越智能、越贴合您的实际需求。Gemini CLI 提供了多种强大的机制来帮助您轻松构建和管理上下文。

## 使用 `@` 引用文件和目录

这是 Gemini CLI 中最常用也最重要的功能之一。通过在提示中使用 `@` 符号，您可以将一个或多个文件、甚至整个目录的内容作为上下文，附加到您的问题中。

### 引用单个文件

假设您有一个名为 `calculator.js` 的文件，内容如下：
```javascript
// calculator.js
function add(a, b) {
  return a + b;
}
```
现在，您想为这个文件添加一个新的减法功能。在 Gemini CLI 中，您可以这样做：

```
> 我正在处理 @calculator.js 文件。请为它添加一个 `subtract` 函数。
```

Gemini CLI 会读取 `calculator.js` 的内容，并将其与您的提示一起发送给模型。模型在理解了现有代码后，会给出一个包含新功能的、完整的代码版本。由于 Gemini CLI 知道您正在修改哪个文件，它还会自动提示您是否要应用变更。

### 引用多个文件

当您的功能逻辑分散在多个文件中时，您可以同时引用它们。

```
> 我的 API 路由定义在 @routes/api.js，而控制器逻辑在 @controllers/userController.js。
> 请分析这两个文件，并告诉我 `createUser` 这个路由的处理流程。
```

### 引用整个目录

如果您想让 Gemini CLI 对整个项目或某个模块有一个全面的理解，您可以直接引用目录。

```
> 请分析 @src 目录下的所有文件，并为这个项目生成一份 README.md 文档。
```

Gemini CLI 会递归地读取 `src` 目录下的所有文件（同时会智能地忽略一些不相关的文件，我们稍后会讲到），并基于对整个代码库的理解来完成您的请求。

## 处理多种文件类型

Gemini CLI 的多模态能力让它不仅仅能处理代码文件。您可以将图片、PDF，甚至音视频文件作为上下文的一部分。

*   **代码审查与UI实现:**
    ```
    > 这是我们产品最新的 UI 设计稿 @design/homepage.png。
    > 请使用 React 和 Tailwind CSS 来实现这个页面的基本布局。
    ```
*   **文档理解与摘要:**
    ```
    > 我需要快速了解这个开源库。这是它的官方文档 @docs/library.pdf。
    > 请为我总结这个库的核心功能和主要 API。
    ```
*   **错误分析:**
    ```
    > 我的应用在手机上崩溃了，这是崩溃时的截图 @screenshots/error.jpg。
    > 你能从这张图里看出可能是什么问题吗？
    ```

## `GEMINI.md` 文件的魔力

`GEMINI.md` 是一个特殊的文件。当您在项目根目录创建一个 `GEMINI.md` 文件时，Gemini CLI 会在每次会话开始时自动读取它的内容，并将其作为**全局上下文**或**系统指令**。

这非常适合用来定义项目级的规则、代码风格指南或提供背景信息。

一个典型的 `GEMINI.md` 文件可能如下所示：

```markdown
# Gemini 指南：我的个人博客项目

## 项目背景
这是一个使用 Next.js 和 TypeScript 构建的个人博客。代码风格遵循 Airbnb JavaScript Style Guide。

## 编码规则
- 优先使用函数式组件和 Hooks。
- 所有组件都需要有对应的单元测试。
- API 请求使用 `fetch` API，并做好错误处理。
- 提交信息必须遵循 Conventional Commits 规范。

## 我的角色
你是一名资深的 Web 开发专家，请在回答时遵循以上所有规则，并以专业的、建设性的口吻提供建议。
```

有了这个文件，您后续的每一次提问，Gemini CLI 都会“记住”这些规则。例如，当您请求创建一个新组件时，它会自动遵循您定义的编码风格，并提醒您编写测试。

## 使用 `.geminiignore` 忽略不需要的文件

当您引用一个目录时, 里面通常会包含一些您不希望 AI 看到的文件, 例如 `node_modules`、构建产物 (`dist`, `.next`)、或者一些包含敏感信息的文件。为了解决这个问题, 您可以在项目根目录创建一个 `.geminiignore` 文件。

它的语法很大程度上遵循 `.gitignore` 文件的约定：
- 空白行或以 `#` 开头的行会被忽略。
- 支持标准的 `*` 等通配符模式。
- 以 `/` 结尾的模式只会匹配目录 (例如, `node_modules/`)。
- 以 `/` 开始的模式会从项目根目录开始匹配。
- 以 `!` 开始的模式表示取反, 可以在一个被忽略的模式中重新包含某个文件。

一个典型的 `.geminiignore` 文件：
```
# 忽略依赖和构建产物
/node_modules/
/dist/
/build/
.next/

# 忽略所有的 .log 文件
*.log

# 但不要忽略这个重要的日志文件
!important.log

# 忽略环境变量文件
.env
.env.local
```

**重要提示:** 如果您修改了 `.geminiignore` 文件, 您必须**重启您的 Gemini CLI 会话**才能让改动生效。

Gemini CLI 在读取目录时会自动查找并遵守 `.geminiignore` 和 `.gitignore` 文件中的规则, 确保只将最相关、最安全的内容作为上下文提供给模型。

通过熟练运用 `@` 引用、`GEMINI.md` 和 `.geminiignore`，您可以精确地控制提供给 AI 的上下文，从而获得更高质量、更具相关性的输出，将 Gemini CLI 的威力发挥到极致。
