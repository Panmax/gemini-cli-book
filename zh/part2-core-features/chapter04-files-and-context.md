# 第四章：玩转文件与上下文

在第一部分中，我们学习了 Gemini CLI 的基础知识。从本章开始，我们将深入探讨其核心功能，而其中最关键、最能体现 Gemini CLI 威力的，莫过于其强大的上下文管理能力。理解并善用上下文，是您从入门到精通的必经之路。

上下文（Context）是指您在与 Gemini 模型对话时提供给它的相关信息。上下文越准确、越充分，模型给出的回答就越智能、越贴合您的实际需求。Gemini CLI 提供了多种强大的机制来帮助您轻松构建和管理上下文。

## 使用 `@` 引用文件和目录

这是 Gemini CLI 中最常用也最重要的功能之一。通过在提示中使用 `@` 符号，您可以将一个或多个文件、甚至整个目录的内容作为上下文，附加到您的问题中。

### 引用单个文件

假设您有一个名为 `calculator.js` 的文件，内容如下：
```javascript
// calculator.js
function add(a, b) {
  return a + b;
}
```
现在，您想为这个文件添加一个新的减法功能。在 Gemini CLI 中，您可以这样做：

```
> 我正在处理 @calculator.js 文件。请为它添加一个 `subtract` 函数。
```

Gemini CLI 会读取 `calculator.js` 的内容，并将其与您的提示一起发送给模型。模型在理解了现有代码后，会给出一个包含新功能的、完整的代码版本。由于 Gemini CLI 知道您正在修改哪个文件，它还会自动提示您是否要应用变更。

### 引用多个文件

当您的功能逻辑分散在多个文件中时，您可以同时引用它们。

```
> 我的 API 路由定义在 @routes/api.js，而控制器逻辑在 @controllers/userController.js。
> 请分析这两个文件，并告诉我 `createUser` 这个路由的处理流程。
```

### 引用整个目录

如果您想让 Gemini CLI 对整个项目或某个模块有一个全面的理解，您可以直接引用目录。

```
> 请分析 @src 目录下的所有文件，并为这个项目生成一份 README.md 文档。
```

Gemini CLI 会递归地读取 `src` 目录下的所有文件（同时会智能地忽略一些不相关的文件，我们稍后会讲到），并基于对整个代码库的理解来完成您的请求。

### 跨多目录扩展上下文
有时，您的项目上下文分散在多个目录中，其中可能包括父级或同级目录。这在复杂的项目结构中很常见，例如您可能需要从一个子目录中引用一个共享的库或文档。

为了处理这种情况，您可以使用 `--include-directories` 标志来为单次会话添加其他文件夹到工作区上下文中。路径可以是相对路径。

```bash
# 从一个子目录中，包含同级的 'lib' 和 'docs' 目录
gemini -p "根据 @../lib/utils.js 和 @../docs/api.md 中的约定，创建一个新函数。" --include-directories ../lib,../docs
```

一旦一个目录被包含进来，您就可以使用 `@` 符号来引用其中的文件，就好像它在您的主工作区中一样。

对于更持久的配置，您可以将这些路径添加到您项目的 `.gemini/settings.json` 文件中：
```json
{
  "context": {
    "includeDirectories": ["../lib", "../docs"]
  }
}
```

## 处理多种文件类型

Gemini CLI 的多模态能力让它不仅仅能处理代码文件。您可以将图片、PDF，甚至音视频文件作为上下文的一部分。

*   **代码审查与UI实现:**
    ```
    > 这是我们产品最新的 UI 设计稿 @design/homepage.png。
    > 请使用 React 和 Tailwind CSS 来实现这个页面的基本布局。
    ```
*   **文档理解与摘要:**
    ```
    > 我需要快速了解这个开源库。这是它的官方文档 @docs/library.pdf。
    > 请为我总结这个库的核心功能和主要 API。
    ```
*   **错误分析:**
    ```
    > 我的应用在手机上崩溃了，这是崩溃时的截图 @screenshots/error.jpg。
    > 你能从这张图里看出可能是什么问题吗？
    ```

## `GEMINI.md` 文件的魔力：分层上下文

`GEMINI.md` 是一个特殊的文件。当您创建一个 `GEMINI.md` 文件时，Gemini CLI 会在每次会话开始时自动读取其内容，并将其用作**全局上下文**或**系统指令**。但其真正的威力在于其**分层加载机制**。

### 向上查找路径
当您启动 `gemini` 时，它会智能地按特定顺序搜索 `GEMINI.md` 文件，从您当前的位置开始，然后向上移动：

1.  **当前及父级目录:** 它会在您当前目录、然后是父目录、再然后是上上级目录……一路向上寻找 `GEMINI.md` 文件，直到项目的根目录（即包含 `.git` 文件夹的目录）。
2.  **全局用户目录:** 最后，它会检查您主目录下的 `~/.gemini/GEMINI.md`，看是否存在一个全局的上下文文件。

所有找到的 `GEMINI.md` 文件内容都会被**合并**在一起。这允许您在项目根目录设置一部“项目宪法”，并在子目录中设置更具体的“地方法规”。

### 实战示例
想象一下您的项目结构：
```
/my-project/
├── GEMINI.md  <-- (项目级规则：使用 TypeScript)
└── src/
    └── components/
        ├── GEMINI.md  <-- (组件级规则：使用函数式组件)
        └── UserProfile/
```
如果您在 `UserProfile` 目录内运行 `gemini`，它会自动加载**两个** `GEMINI.md` 文件。这样，AI 就会同时知道要遵循项目级的规则（使用 TypeScript）和组件级的规则（使用函数式组件）。

### 如何验证
您可以随时使用 `/memory show` 命令来精确地查看当前加载了哪些上下文文件。这是调试和理解模型所获上下文的绝佳方式。

### `GEMINI.md` 内容示例
一个位于项目根目录的典型 `GEMINI.md` 文件可能如下所示：
```markdown
# Gemini 指南：我的个人博客项目

## 项目背景
这是一个使用 Next.js 和 TypeScript 构建的个人博客。代码风格遵循 Airbnb JavaScript Style Guide。

## 编码规则
- 优先使用函数式组件和 Hooks。
- 所有组件都需要有对应的单元测试。
- 提交信息必须遵循 Conventional Commits 规范。

## 我的角色
你是一名资深的 Web 开发专家，请在回答时遵循以上所有规则。
```

## 使用 `.geminiignore` 忽略不需要的文件

当您引用一个目录时, 里面通常会包含一些您不希望 AI 看到的文件, 例如 `node_modules`、构建产物 (`dist`, `.next`)、或者一些包含敏感信息的文件。为了解决这个问题, 您可以在项目根目录创建一个 `.geminiignore` 文件。

它的语法很大程度上遵循 `.gitignore` 文件的约定：
- 空白行或以 `#` 开头的行会被忽略。
- 支持标准的 `*` 等通配符模式。
- 以 `/` 结尾的模式只会匹配目录 (例如, `node_modules/`)。
- 以 `/` 开始的模式会从项目根目录开始匹配。
- 以 `!` 开始的模式表示取反, 可以在一个被忽略的模式中重新包含某个文件。

一个典型的 `.geminiignore` 文件：
```
# 忽略依赖和构建产物
/node_modules/
/dist/
/build/
.next/

# 忽略所有的 .log 文件
*.log

# 但不要忽略这个重要的日志文件
!important.log

# 忽略环境变量文件
.env
.env.local
```

**重要提示:** 如果您修改了 `.geminiignore` 文件, 您必须**重启您的 Gemini CLI 会话**才能让改动生效。

Gemini CLI 在读取目录时会自动查找并遵守 `.geminiignore` 和 `.gitignore` 文件中的规则, 确保只将最相关、最安全的内容作为上下文提供给模型。

通过熟练运用 `@` 引用、`GEMINI.md` 和 `.geminiignore`，您可以精确地控制提供给 AI 的上下文，从而获得更高质量、更具相关性的输出，将 Gemini CLI 的威力发挥到极致。
