# 第五章：强大的内置工具

Gemini CLI 的强大之处不仅在于它能理解和生成语言，更在于它被赋予了执行具体“动作”的能力。这些动作由一系列内置的“工具” (Tools) 提供，它们让 Gemini CLI 能够与您的本地环境和互联网进行交互，从而完成更复杂的任务。

模型会根据您的指令，智能地决定是否以及如何使用这些工具。在本章中，我们将探索几类最核心的内置工具。

## 文件系统工具

文件系统工具赋予了 Gemini CLI 直接读写本地文件的能力。这意味着 AI 可以像您一样，查看文件内容、创建新文件或修改现有文件。

在前面的章节中，当我们让 AI 生成 `server.js` 并保存时，它其实就是在后台调用了 `write-file` 这个工具。

### 常见文件工具

*   `read_file`: 读取指定文件的内容。
*   `write_file`: 将内容写入指定文件（如果文件已存在，则会覆盖）。
*   `list_directory`: 列出指定目录下的文件和子目录。

### 实战示例：代码重构

假设您有一个很长的函数，您希望将其拆分到多个文件中。

**您的提示：**
```
> 我觉得 @src/utils.js 这个文件太大了。
> 请把里面的 `networkRequest` 和 `dataProcessing` 函数抽离出来，
> 分别放到 @src/network.js 和 @src/data.js 两个新文件中，
> 并在原文件 (`utils.js`) 中删除这两个函数。
```

**Gemini CLI 的执行过程：**

1.  **智能规划:** 模型接收到指令后，会分析出这是一个多步骤的文件操作任务。
2.  **调用 `read_file`:** 首先，它会调用 `read_file` 工具来读取 `src/utils.js` 的完整内容，以确保它理解了要移动的函数。
3.  **调用 `write_file`:** 接着，它会两次调用 `write_file` 工具：
    *   第一次，创建 `src/network.js` 并将 `networkRequest` 函数的代码写入。
    *   第二次，创建 `src/data.js` 并将 `dataProcessing` 函数的代码写入。
4.  **再次调用 `write_file`:** 最后，它会再次调用 `write_file` 来更新 `src/utils.js`，将已经抽离出去的两个函数删除。
5.  **用户确认:** 在每一步关键的文件写入操作前，Gemini CLI 都会向您请求确认，确保一切都在您的掌控之中。

通过这种方式，Gemini CLI 将一个复杂的重构任务，分解为一系列对文件系统工具的原子调用，既自动化了流程，又保证了安全。

## 与版本控制集成 (Git)

出于安全原因，Gemini CLI 并未提供一个可以执行任意 shell 命令的工具。但是，您仍然可以通过将标准的 shell 功能与 CLI 的上下文能力相结合，来创建强大且安全的工作流。一个绝佳的例子就是生成 Git 提交信息。

您可以将 `git` 命令的输出重定向到一个文件中，然后将该文件作为上下文传递给 AI，而不是要求 AI 直接运行 `git` 命令。

### 实战示例：生成 Commit Message

**第一步：将您暂存的变更保存到一个文件**
在您的终端中，运行以下命令，将 `git diff --cached` 的输出保存到一个名为 `changes.diff` 的文件中。
```bash
git diff --cached > changes.diff
```

**第二步：请求 Gemini CLI 生成信息**
现在，将这个文件作为上下文传递给 Gemini CLI。
```
> @changes.diff
> 基于这个 diff 文件中的代码变更，请为我撰写一条简洁并符合规范的 commit message。
```

**Gemini CLI 的执行过程：**

1.  **读取文件:** CLI 将使用其内置的 `read_file` 工具读取 `changes.diff` 的内容。
2.  **分析并生成:** 模型将分析 diff 文件中提供的代码变更，并生成一条能够准确描述这些变更的高质量提交信息。
3.  **清理:** 之后，您可以删除临时的 `changes.diff` 文件。

这种方法既强大又安全。它允许您利用 AI 对代码变更的全部分析能力，而无需授予其执行潜在危险命令的权限。

## Web 获取工具

现代开发离不开海量网络信息的获取。Gemini CLI 内置了 Web 获取工具，使其具备实时访问互联网的能力。

*   `web_fetch`: 从一个或多个 URL 中获取内容。
*   `google_web_search`: 执行 Google 搜索并返回结果。

### 实战示例

**示例一：学习新技术**
```
> 我想学习如何在 React 中使用 Zustand 来进行状态管理。
> 请搜索相关的官方文档或优秀教程，并为我提供一个入门示例。
```
模型会调用 `google_web_search` 工具搜索 "React Zustand tutorial"，然后可能会找到 Zustand 在 GitHub 上的官方文档。接着，它会调用 `web_fetch` 工具来读取文档页面的内容，并最终根据这些信息，为您总结核心概念并生成一个入门代码示例。

**示例二：解决报错信息**
```
> 我的 Next.js 应用在启动时报了一个错：
> "Error: connect ECONNREFUSED 127.0.0.1:6379"
> 这通常是什么原因造成的？请帮我搜索一下解决方案。
```
模型会使用 `google_web_search` 工具搜索这个具体的错误信息，并根据搜索结果（很可能来自 Stack Overflow 或 GitHub Issues），为您分析出这通常是由于本地 Redis 服务未启动导致的，并给出启动 Redis 服务的建议命令。

通过将语言能力与这些强大的内置工具相结合，Gemini CLI 从一个单纯的“聊天机器人”转变为一个能够感知环境、执行操作、获取新知的“智能体” (Agent)，真正成为您开发工作流中的得力助手。

## 在脚本和自动化中使用 Gemini CLI (无头模式)

除了交互式的 shell 界面，Gemini CLI 也是一个强大的自动化工具。通过使用**无头模式 (headless mode)**，您可以将其 AI 能力直接集成到您的脚本、CI/CD 流水线以及其他自动化工作流中。

### 工作原理
无头模式以非交互方式运行 CLI。它不再提供聊天界面，而是直接接受一个提示，处理它，然后将结果打印到标准输出，最后退出。这使其非常适合程序化使用。

您可以通过两种主要方式提供输入：
1.  **通过 `--prompt` (或 `-p`) 标志:**
    ```bash
    gemini --prompt "为最新的代码变更写一条简洁的 git commit 信息" --output-format json
    ```
2.  **通过标准输入 (stdin):** 这允许您将其他命令（如 `cat`）的输出通过管道直接传递给 Gemini CLI 作为上下文。
    ```bash
    cat src/utils.js | gemini -p "请为这段 JavaScript 代码生成 JSDoc 风格的文档。"
    ```

### 获取结构化输出
对于自动化而言，接收一个可预测的、结构化的输出至关重要。您可以使用 `--output-format json` 标志来获取一个详细的 JSON 对象作为响应。这个对象不仅包含 AI 的文本回复，还包含了关于模型和工具使用情况的宝贵元数据和统计信息。

```bash
# 获取 JSON 格式的响应，并使用 `jq` 工具只提取其中的文本部分
gemini -p "法国的首都是哪里？" --output-format json | jq '.response'
```

> **关于兼容性的说明:** `--output-format json` 是一个强大的脚本功能，但在 2025 年末，它可能尚未在所有公开的稳定版本中可用，并可能导致 "Unknown arguments" (未知参数) 错误。该功能在预览版中可用，并有望成为标准命令集的一部分。如果您遇到此错误，请查阅 `gemini-cli` 的官方文档以获取最新的命令更新。

无头模式与结构化 JSON 输出的结合，为您在命令行中构建由 AI 驱动的自动化流程开启了无限可能。
