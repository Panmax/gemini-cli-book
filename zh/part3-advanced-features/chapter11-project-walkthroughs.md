# 第十章：项目级实战演练

理论知识固然重要，但真正的掌握来自于实践。在本章中，我们将通过三个完整的项目级实战案例，将前面学到的所有知识点——上下文管理、工具使用、IDE 集成等——串联起来，向您展示如何在真实的开发场景中运用 Gemini CLI 解决问题。

为了方便演练，我们假设正在处理一个名为 `todo-cli` 的小型开源项目，这是一个用于在命令行管理待办事项的 Node.js 工具。

---

## 案例一：代码理解与重构

**场景:** 您刚刚接手 `todo-cli` 这个项目，需要快速熟悉其代码结构，并对其核心逻辑进行一次简单的重构。

**第一步：克隆项目并进行初步理解**

首先，我们使用 shell 工具克隆项目。

```
> !git clone https://github.com/example/todo-cli.git
> !cd todo-cli
```

项目克隆下来了，但我们对代码一无所知。现在，让我们利用 Gemini CLI 的全局理解能力。

```
> 我想快速了解这个项目。请分析 @. 目录下的所有文件，并总结一下这个项目的
> 主要功能、技术栈和代码结构。
```

Gemini CLI 会读取项目中的所有文件（遵循 `.gitignore` 规则），然后给出一个概要报告，可能如下：
> `todo-cli` 是一个使用 Node.js 和 `yargs` 库构建的命令行工具。它的主要功能是添加、列出和完成待办事项。数据存储在一个名为 `tasks.json` 的本地文件中。核心逻辑位于 `index.js`，其中包含了所有命令的实现。

**第二步：聚焦核心逻辑并提出重构建议**

通过概要，我们知道了核心逻辑在 `index.js`。现在，我们来深入分析这个文件，并寻求重构建议。

```
> @index.js
> 请分析这个文件。我认为所有功能都挤在一起，代码可能有些混乱。
> 你有什么好的重构建议吗？
```

Gemini CLI 在分析了 `index.js` 后，可能会回答：
> 是的，目前所有命令（add, list, done）的实现都直接写在了 `yargs` 的配置中。一个好的重构方向是将这些核心的业务逻辑（如读写 `tasks.json` 文件、处理任务数据）抽离到独立的模块中。例如，我们可以创建一个 `lib/tasks.js` 模块来专门负责任务管理。

**第三步：应用代码变更**

这个建议听起来不错。让我们让 Gemini CLI 来执行这个重构。

```
> 这个建议很好。请按照你说的，创建一个 `lib/tasks.js` 文件，
> 将所有与任务读写相关的逻辑（例如 `loadTasks`, `saveTasks`, `addTask` 等）
> 从 `index.js` 移动到新文件中。
> 然后，更新 `index.js`，让它调用新模块中的函数。
```

接下来，神奇的事情发生了。Gemini CLI 会在后台执行一系列操作：
1.  **读取** `index.js` 的内容。
2.  **创建** `lib/tasks.js` 并写入抽离出来的函数。
3.  **重写** `index.js`，删除旧逻辑并添加 `require('./lib/tasks')` 以及对新函数的调用。

在启用 [IDE 集成](#第八章集成开发环境-ide-集成) 的情况下，这些变更会直接以**差分视图**的形式出现在您的 VS Code 中，等待您的审查和批准。只需轻轻一点，一次清晰、安全的代码重构就完成了。

---

## 案例二：Bug 修复与测试生成

**场景:** 用户报告了一个 Bug：当 `tasks.json` 文件不存在时，运行 `todo-cli list` 命令会导致程序崩溃。我们需要复现问题、修复它，并为修复添加单元测试。

**第一步：定位并修复 Bug**

我们不确定问题出在哪里，所以我们把错误信息直接告诉 Gemini CLI。

```
> 当 tasks.json 文件不存在时，运行 `list` 命令会崩溃，错误是 "ENOENT: no such file or directory"。
> @index.js @lib/tasks.js
> 请帮我定位问题并生成修复方案。
```

Gemini CLI 会分析 `loadTasks` 函数，并很快发现问题所在：
> 问题出在 `lib/tasks.js` 的 `loadTasks` 函数中。它直接尝试使用 `fs.readFileSync` 读取文件，但没有处理文件不存在的情况。您应该在读取前检查文件是否存在，或者使用 `try...catch` 块来捕获异常。

**您的下一个提示：**
```
> 好的，请使用 try...catch 的方式修复这个问题。
> 在 catch 块中，如果错误是 "ENOENT"，应该返回一个空数组 `[]`，表示没有任何任务。
```

Gemini CLI 会立即为您生成修复后的 `loadTasks` 函数代码，并提示您应用对 `lib/tasks.js` 文件的修改。

**第二步：自动生成单元测试**

Bug 修复了，但为了防止未来再次出现类似问题，我们需要添加单元测试。

```
> 我需要为 `lib/tasks.js` 模块编写单元测试，请使用 `jest` 框架。
> 测试需要覆盖以下场景：
> 1. 当 tasks.json 文件存在且包含数据时，`loadTasks` 能正确读取。
> 2. 当 tasks.json 文件不存在时，`loadTasks` 能返回空数组（验证我们的 Bug 修复）。
> 3. `saveTasks` 函数能够被正确调用。
```

Gemini CLI 会为您生成一个完整的测试文件，可能名为 `lib/tasks.test.js`，包含所有必要的 `jest` 代码、`mock` 和断言。您只需将文件保存，然后运行测试即可。

```
> !npx jest
```

---

## 案例三：从零到一创建新功能

**场景:** 我们要为 `todo-cli` 添加一个全新的“归档”功能：允许用户将已完成的任务从主列表移动到一个 `archive.json` 文件中。

**第一步：规划新功能**

我们先通过对话，与 Gemini CLI 一起规划功能的实现步骤。

```
> 我想增加一个 `archive` 命令。它的功能是：
> 1. 读取 `tasks.json` 文件。
> 2. 筛选出所有状态为 "done" 的任务。
> 3. 将这些已完成的任务从 `tasks.json` 中移除。
> 4. 将它们追加到 `archive.json` 文件中。
> 请为我规划一下实现这个功能的代码修改步骤。
```

Gemini CLI 会给出一个清晰的计划：
> 好的，这是一个可行的计划：
> 1.  在 `lib/tasks.js` 中，新增一个 `archiveTasks` 函数来处理核心逻辑。
> 2.  这个函数需要读取 `tasks.json` 和 `archive.json`（如果存在）。
> 3.  它会过滤任务，并分别调用 `saveTasks` 来更新两个文件。
> 4.  在 `index.js` 中，新增一个 `archive` 命令的定义，让它调用 `lib/tasks.js` 中的 `archiveTasks` 函数。

**第二步：分步生成代码**

计划清晰了，我们就可以让 Gemini CLI 一步步地为我们写代码。

```
> 好的，我们先从第一步开始。请在 `lib/tasks.js` 中创建 `archiveTasks` 函数的骨架。
```
... 应用代码 ...
```
> 很好，现在为这个函数填充筛选和文件读写的逻辑。
```
... 应用代码 ...
```
> `lib/tasks.js` 看起来完成了。现在请修改 `index.js`，添加新的 `archive` 命令。
```
... 应用代码 ...

**第三步：利用多模态能力生成文档插图**

新功能完成了，我们需要更新文档。也许我们可以为文档加个流程图？

```
> 我想为 `archive` 功能写文档，需要一张流程图来说明它的工作原理。
> 流程包括：开始 -> 读取任务 -> 筛选已完成任务 -> 更新 tasks.json -> 更新 archive.json -> 结束。
> 请帮我生成这张流程图的 Graphviz (DOT 语言) 描述。
```

Gemini CLI 会为您生成 DOT 语言代码，您可以将其粘贴到 Graphviz 工具中，立即生成一张清晰的流程图，完美地用于您的项目文档。

通过以上三个案例，您可以看到 Gemini CLI 如何作为一个全能的开发伙伴，深度参与到软件开发的整个生命周期中——从最初的代码理解，到重构、调试、测试，再到全新功能的创造。
